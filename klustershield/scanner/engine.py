"""
KlusterShield Compliance Scanner

Scans a Kubernetes cluster or namespace against NIST SP 800-218 (SSDF) controls.
Each check is mapped to a specific SSDF practice and produces a PASS/FAIL/WARN result.
Generates a weighted compliance score and HTML/JSON report.
"""

from __future__ import annotations

import json
import os
import sys
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Callable

from jinja2 import Environment, StrictUndefined
from kubernetes import client, config
from kubernetes.client.exceptions import ApiException
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

console = Console()

REPORT_TEMPLATE = """<!DOCTYPE html>
<html lang=\"en\">
<head>
    <meta charset=\"UTF-8\">
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; style-src 'unsafe-inline'; img-src data:; base-uri 'none'; form-action 'none'\">
    <title>KlusterShield Compliance Report</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
               margin: 0; padding: 2rem; background: #0f172a; color: #e2e8f0; }
        h1 { color: #60a5fa; } h2 { color: #94a3b8; }
        .score { font-size: 4rem; font-weight: bold; color: {{ score_color }}; }
        .meta { display: flex; gap: 2rem; margin: 1rem 0; }
        .meta span { background: #1e293b; padding: 0.5rem 1rem; border-radius: 0.5rem; }
        table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        th { background: #1e293b; padding: 0.75rem; text-align: left; color: #60a5fa; }
        td { padding: 0.75rem; border-bottom: 1px solid #1e293b; vertical-align: top; }
        tr:hover td { background: #1e293b; }
        code { background: #0f172a; padding: 0.2rem 0.4rem; border-radius: 0.25rem; color: #60a5fa; }
        .severity { padding: 0.2rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem; font-weight: bold; }
        .severity.critical { background: #7f1d1d; color: #fca5a5; }
        .severity.high { background: #7c2d12; color: #fdba74; }
        .severity.medium { background: #713f12; color: #fde68a; }
        .severity.low { background: #14532d; color: #86efac; }
        .status-pass { color:#22c55e;font-weight:bold; }
        .status-fail { color:#ef4444;font-weight:bold; }
        .status-warn { color:#eab308;font-weight:bold; }
        .status-skip { color:#6b7280; }
        .footer { margin-top: 2rem; color: #475569; font-size: 0.875rem; text-align: center; }
    </style>
</head>
<body>
    <h1>üõ°Ô∏è KlusterShield Compliance Report</h1>
    <div class="meta">
        <span>Profile: <strong>{{ profile }}</strong></span>
        <span>Scope: <strong>{{ scope }}</strong></span>
        <span>Passed: <strong style="color:#22c55e">{{ passed }}</strong></span>
        <span>Failed: <strong style="color:#ef4444">{{ failed }}</strong></span>
        <span>Warned: <strong style="color:#eab308">{{ warned }}</strong></span>
        <span>Errors: <strong style="color:#f97316">{{ error_count }}</strong></span>
    </div>
    <div class="score">{{ score }}%</div>
    <h2>NIST SP 800-218 (SSDF) Compliance Score</h2>
    <table>
        <thead>
            <tr>
                <th>Control</th><th>Check</th><th>Severity</th>
                <th>Status</th><th>Finding</th><th>Remediation</th>
            </tr>
        </thead>
        <tbody>
            {% for row in rows %}
            <tr>
                <td><code>{{ row.control_id }}</code></td>
                <td>{{ row.title }}</td>
                <td><span class="severity {{ row.severity_class }}">{{ row.severity }}</span></td>
                <td><span class="{{ row.status_class }}">{{ row.status_label }}</span></td>
                <td>{{ row.finding }}</td>
                <td>{{ row.remediation }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
    <div class="footer">
        Generated by <a href="https://github.com/rudymartinezai/klustershield" style="color:#60a5fa">KlusterShield</a>
        ‚Äî Apache 2.0 License
    </div>
</body>
</html>
"""


class Status(str, Enum):
    PASS = "PASS"
    FAIL = "FAIL"
    WARN = "WARN"
    SKIP = "SKIP"


@dataclass
class ControlCheck:
    control_id: str  # e.g. "PO.1.1"
    control_family: str  # e.g. "PO - Prepare the Organization"
    title: str
    description: str
    severity: str  # critical / high / medium / low
    status: Status = Status.SKIP
    finding: str = ""
    remediation: str = ""


@dataclass
class ScanResult:
    namespace: str | None
    profile: str
    checks: list[ControlCheck] = field(default_factory=list)
    error_count: int = 0

    @property
    def score(self) -> float:
        """Weighted compliance score 0-100."""
        weights = {"critical": 4, "high": 3, "medium": 2, "low": 1}
        total_weight = sum(weights[c.severity] for c in self.checks if c.status != Status.SKIP)
        passed_weight = sum(weights[c.severity] for c in self.checks if c.status == Status.PASS)
        if total_weight == 0:
            return 0.0
        return round((passed_weight / total_weight) * 100, 1)

    @property
    def passed(self) -> int:
        return sum(1 for c in self.checks if c.status == Status.PASS)

    @property
    def failed(self) -> int:
        return sum(1 for c in self.checks if c.status == Status.FAIL)

    @property
    def warned(self) -> int:
        return sum(1 for c in self.checks if c.status == Status.WARN)

    @property
    def skipped(self) -> int:
        return sum(1 for c in self.checks if c.status == Status.SKIP)


class ComplianceScanner:
    """
    Runs NIST 800-218 compliance checks against a live Kubernetes cluster.

    Checks are organized by SSDF practice family:
    PO (Prepare), PS (Protect Software), PW (Produce Well-Secured),
    RV (Respond to Vulnerabilities), DS (Distribute Securely), PV (Verify)
    """

    def __init__(self, profile: str = "nist-800-218"):
        self.profile = profile
        self._load_kube_config()
        self.core_v1 = client.CoreV1Api()
        self.apps_v1 = client.AppsV1Api()
        self.networking_v1 = client.NetworkingV1Api()
        self.rbac_v1 = client.RbacAuthorizationV1Api()

    @staticmethod
    def _all_containers(pod: client.V1Pod) -> list[Any]:
        """Return all container types to avoid compliance blind spots."""
        containers: list[Any] = list(pod.spec.containers or [])
        containers += list(pod.spec.init_containers or [])
        containers += list(pod.spec.ephemeral_containers or [])
        return containers

    def _load_kube_config(self) -> None:
        try:
            config.load_incluster_config()
        except config.ConfigException:
            config.load_kube_config()

    def scan(self, namespace: str | None = None) -> ScanResult:
        result = ScanResult(namespace=namespace, profile=self.profile)

        checks: list[tuple[str, Callable[..., ControlCheck]]] = [
            # PO ‚Äî Prepare the Organization
            ("PO.1.1 ‚Äì Security requirements defined", self._check_pod_security_admission),
            ("PO.3.2 ‚Äì Toolchain controls in place", self._check_network_policies_exist),
            # PS ‚Äî Protect Software
            ("PS.1.1 ‚Äì Privileged containers blocked", self._check_no_privileged_containers),
            ("PS.2.1 ‚Äì Root containers blocked", self._check_no_root_containers),
            # PW ‚Äî Produce Well-Secured Software
            ("PW.4.1 ‚Äì Resource limits enforced", self._check_resource_limits),
            ("PW.7.2 ‚Äì Read-only root filesystem", self._check_readonly_root_fs),
            # RV ‚Äî Respond to Vulnerabilities
            ("RV.1.3 ‚Äì Image tags pinned (no :latest)", self._check_no_latest_tags),
            ("RV.3.3 ‚Äì hostPID/hostNetwork disabled", self._check_host_namespaces),
            # DS ‚Äî Distribute Securely
            ("DS.1.1 ‚Äì Default deny network policy", self._check_default_deny_policy),
            ("DS.2.1 ‚Äì Secrets not in env vars", self._check_secrets_not_in_env),
            # PV ‚Äî Verify with Automated Testing
            ("PV.1.1 ‚Äì RBAC enabled and configured", self._check_rbac_configured),
            ("PV.1.2 ‚Äì ServiceAccount tokens not auto-mounted", self._check_service_account_tokens),
        ]

        console.rule("[bold blue]KlusterShield Compliance Scan[/bold blue]")
        console.print(f"Profile: [cyan]{self.profile}[/cyan]")
        console.print(f"Scope: [cyan]{namespace or 'cluster-wide'}[/cyan]\n")

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
        ) as progress:
            for check_name, check_fn in checks:
                task = progress.add_task(f"Checking {check_name}...", total=None)
                try:
                    check_result = check_fn(namespace=namespace)
                    result.checks.append(check_result)
                except ApiException as exc:
                    result.error_count += 1
                    if exc.status == 403:
                        check_result = ControlCheck(
                            control_id="ERR",
                            control_family="Error",
                            title=check_name,
                            description="Check failed due to RBAC permissions",
                            severity="high",
                            status=Status.FAIL,
                            finding=(
                                "Insufficient Kubernetes RBAC permissions to run this check "
                                f"(HTTP {exc.status}: {exc.reason})"
                            ),
                            remediation=("Grant read permissions for the required resource and rerun scan"),
                        )
                    elif exc.status == 404:
                        check_result = ControlCheck(
                            control_id="ERR",
                            control_family="Error",
                            title=check_name,
                            description="Check skipped due to missing resource",
                            severity="low",
                            status=Status.SKIP,
                            finding=f"Resource not found (HTTP {exc.status}: {exc.reason})",
                        )
                    else:
                        check_result = ControlCheck(
                            control_id="ERR",
                            control_family="Error",
                            title=check_name,
                            description="Check failed to execute",
                            severity="medium",
                            status=Status.SKIP,
                            finding=f"Kubernetes API error (HTTP {exc.status}: {exc.reason})",
                        )
                    print(f"[klustershield] check error for '{check_name}': {exc}", file=sys.stderr)
                    result.checks.append(check_result)
                except Exception as exc:
                    result.error_count += 1
                    check_result = ControlCheck(
                        control_id="ERR",
                        control_family="Error",
                        title=check_name,
                        description="Check failed to execute",
                        severity="medium",
                        status=Status.SKIP,
                        finding=f"Unexpected error: {exc}",
                    )
                    print(f"[klustershield] check error for '{check_name}': {exc}", file=sys.stderr)
                    result.checks.append(check_result)
                progress.remove_task(task)

        self._print_results_table(result)
        return result

    def _print_results_table(self, result: ScanResult) -> None:
        table = Table(title="Compliance Scan Results", show_header=True, show_lines=True)
        table.add_column("Control", style="cyan", min_width=10)
        table.add_column("Check", min_width=35)
        table.add_column("Severity", min_width=10)
        table.add_column("Status", min_width=8)
        table.add_column("Finding")

        status_styles = {
            Status.PASS: "[bold green]PASS[/bold green]",
            Status.FAIL: "[bold red]FAIL[/bold red]",
            Status.WARN: "[bold yellow]WARN[/bold yellow]",
            Status.SKIP: "[dim]SKIP[/dim]",
        }

        for check in result.checks:
            table.add_row(
                check.control_id,
                check.title,
                check.severity.upper(),
                status_styles[check.status],
                check.finding[:80] + "..." if len(check.finding) > 80 else check.finding,
            )

        console.print(table)

        score_color = "green" if result.score >= 80 else "yellow" if result.score >= 60 else "red"
        console.print(f"\n[bold]Compliance Score:[/bold] [{score_color}]{result.score}%[/{score_color}]")
        console.print(
            f"  Passed: [green]{result.passed}[/green]  "
            f"Failed: [red]{result.failed}[/red]  "
            f"Warned: [yellow]{result.warned}[/yellow]  "
            f"Skipped: [dim]{result.skipped}[/dim]  "
            f"Errors: [bold]{result.error_count}[/bold]"
        )

    def _resolve_output_path(self, output_path: str) -> Path:
        candidate = Path(output_path).expanduser().resolve()
        safe_base = Path.cwd().resolve()

        if candidate.suffix not in {".html", ".json"}:
            raise ValueError("Output path must end with .html or .json")

        if safe_base == Path(safe_base.anchor):
            raise ValueError("Refusing to write output when current directory is filesystem root")

        if not str(candidate).startswith(str(safe_base) + os.sep):
            raise ValueError(f"Output path must be within current working directory: {safe_base}")

        if candidate.exists():
            console.print(f"[yellow]Warning:[/yellow] overwriting existing file: {candidate}")

        candidate.parent.mkdir(parents=True, exist_ok=True)
        return candidate

    def report(self, result: ScanResult, output_path: str) -> None:
        """Generate HTML or JSON compliance report."""
        path = self._resolve_output_path(output_path)

        if path.suffix == ".json":
            self._write_json_report(result, path)
        else:
            self._write_html_report(result, path)

        console.print(f"\nReport written to: [cyan]{path}[/cyan]")

    def _write_json_report(self, result: ScanResult, path: Path) -> None:
        data = {
            "profile": result.profile,
            "namespace": result.namespace,
            "score": result.score,
            "summary": {
                "passed": result.passed,
                "failed": result.failed,
                "warned": result.warned,
                "skipped": result.skipped,
                "error_count": result.error_count,
            },
            "checks": [
                {
                    "control_id": c.control_id,
                    "title": c.title,
                    "severity": c.severity,
                    "status": c.status.value,
                    "finding": c.finding,
                    "remediation": c.remediation,
                }
                for c in result.checks
            ],
        }
        path.write_text(json.dumps(data, indent=2), encoding="utf-8")

    def _write_html_report(self, result: ScanResult, path: Path) -> None:
        score_color = "#22c55e" if result.score >= 80 else "#eab308" if result.score >= 60 else "#ef4444"

        rows = []
        for c in result.checks:
            status_class, status_label = {
                Status.PASS: ("status-pass", "PASS"),
                Status.FAIL: ("status-fail", "FAIL"),
                Status.WARN: ("status-warn", "WARN"),
                Status.SKIP: ("status-skip", "SKIP"),
            }[c.status]
            rows.append(
                {
                    "control_id": c.control_id,
                    "title": c.title,
                    "severity": c.severity.upper(),
                    "severity_class": c.severity,
                    "status_class": status_class,
                    "status_label": status_label,
                    "finding": c.finding,
                    "remediation": c.remediation,
                }
            )

        env = Environment(autoescape=True, undefined=StrictUndefined)
        template = env.from_string(REPORT_TEMPLATE)
        html = template.render(
            profile=result.profile,
            scope=result.namespace or "cluster-wide",
            passed=result.passed,
            failed=result.failed,
            warned=result.warned,
            error_count=result.error_count,
            score=result.score,
            score_color=score_color,
            rows=rows,
        )
        path.write_text(html, encoding="utf-8")

    # ‚îÄ‚îÄ Individual control checks ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _check_pod_security_admission(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="PO.1.1",
            control_family="PO - Prepare the Organization",
            title="PodSecurityAdmission labels enforced",
            description="Namespaces should enforce the 'restricted' PodSecurity profile",
            severity="critical",
        )
        namespaces = [self.core_v1.read_namespace(namespace)] if namespace else self.core_v1.list_namespace().items
        missing = [
            ns.metadata.name
            for ns in namespaces
            if (ns.metadata.labels or {}).get("pod-security.kubernetes.io/enforce") != "restricted"
            and not ns.metadata.name.startswith("kube-")
        ]
        if missing:
            check.status = Status.FAIL
            check.finding = f"Namespaces missing restricted PSA label: {', '.join(missing)}"
            check.remediation = "Run: kubectl label namespace <ns> " "pod-security.kubernetes.io/enforce=restricted"
        else:
            check.status = Status.PASS
            check.finding = "All namespaces enforce PodSecurity restricted profile"
        return check

    def _check_network_policies_exist(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="PO.3.2",
            control_family="PO - Prepare the Organization",
            title="NetworkPolicies exist in namespace(s)",
            description="Every namespace should have at least one NetworkPolicy",
            severity="high",
        )
        if namespace:
            policies = self.networking_v1.list_namespaced_network_policy(namespace).items
            if not policies:
                check.status = Status.FAIL
                check.finding = f"No NetworkPolicies found in namespace '{namespace}'"
                check.remediation = "Run: klustershield provision --namespace <ns>"
            else:
                check.status = Status.PASS
                check.finding = f"Found {len(policies)} NetworkPolicy/ies"
        else:
            check.status = Status.WARN
            check.finding = "Cluster-wide scan: specify --namespace for detailed NetworkPolicy check"
        return check

    def _check_no_privileged_containers(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="PS.1.1",
            control_family="PS - Protect Software",
            title="No privileged containers running",
            description="Containers must not run with privileged:true",
            severity="critical",
        )
        pods = (
            self.core_v1.list_namespaced_pod(namespace).items
            if namespace
            else self.core_v1.list_pod_for_all_namespaces().items
        )
        privileged = [
            f"{p.metadata.namespace}/{p.metadata.name}"
            for p in pods
            for c in self._all_containers(p)
            if c.security_context and c.security_context.privileged
        ]
        if privileged:
            check.status = Status.FAIL
            check.finding = f"Privileged containers found: {', '.join(privileged[:5])}"
            check.remediation = "Set securityContext.privileged: false on all containers"
        else:
            check.status = Status.PASS
            check.finding = "No privileged containers detected"
        return check

    def _check_no_root_containers(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="PS.2.1",
            control_family="PS - Protect Software",
            title="Containers not running as root",
            description="Containers should set runAsNonRoot: true",
            severity="high",
        )
        pods = (
            self.core_v1.list_namespaced_pod(namespace).items
            if namespace
            else self.core_v1.list_pod_for_all_namespaces().items
        )
        root_containers = [
            f"{p.metadata.namespace}/{p.metadata.name}"
            for p in pods
            for c in self._all_containers(p)
            if not (c.security_context and c.security_context.run_as_non_root)
            and not p.metadata.namespace.startswith("kube-")
        ]
        if root_containers:
            check.status = Status.WARN
            check.finding = f"{len(root_containers)} containers missing runAsNonRoot:true"
            check.remediation = "Set securityContext.runAsNonRoot: true on all containers"
        else:
            check.status = Status.PASS
            check.finding = "All containers configured to run as non-root"
        return check

    def _check_resource_limits(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="PW.4.1",
            control_family="PW - Produce Well-Secured Software",
            title="Resource limits set on all containers",
            description="CPU and memory limits must be defined on every container",
            severity="medium",
        )
        pods = (
            self.core_v1.list_namespaced_pod(namespace).items
            if namespace
            else self.core_v1.list_pod_for_all_namespaces().items
        )
        missing = [
            f"{p.metadata.namespace}/{p.metadata.name}"
            for p in pods
            for c in self._all_containers(p)
            if (not c.resources or not c.resources.limits) and not p.metadata.namespace.startswith("kube-")
        ]
        if missing:
            check.status = Status.FAIL
            check.finding = f"{len(missing)} containers missing resource limits"
            check.remediation = "Add resources.limits.cpu and resources.limits.memory to all containers"
        else:
            check.status = Status.PASS
            check.finding = "All containers have resource limits defined"
        return check

    def _check_readonly_root_fs(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="PW.7.2",
            control_family="PW - Produce Well-Secured Software",
            title="Read-only root filesystem enforced",
            description="Containers should use readOnlyRootFilesystem: true",
            severity="medium",
        )
        pods = (
            self.core_v1.list_namespaced_pod(namespace).items
            if namespace
            else self.core_v1.list_pod_for_all_namespaces().items
        )
        writable = [
            f"{p.metadata.namespace}/{p.metadata.name}"
            for p in pods
            for c in self._all_containers(p)
            if not (c.security_context and c.security_context.read_only_root_filesystem)
            and not p.metadata.namespace.startswith("kube-")
        ]
        if writable:
            check.status = Status.WARN
            check.finding = f"{len(writable)} containers with writable root filesystems"
            check.remediation = "Set securityContext.readOnlyRootFilesystem: true"
        else:
            check.status = Status.PASS
            check.finding = "All containers use read-only root filesystems"
        return check

    def _check_no_latest_tags(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="RV.1.3",
            control_family="RV - Respond to Vulnerabilities",
            title="No :latest image tags in use",
            description="Image tags must be pinned to specific versions",
            severity="high",
        )
        pods = (
            self.core_v1.list_namespaced_pod(namespace).items
            if namespace
            else self.core_v1.list_pod_for_all_namespaces().items
        )
        latest_images = [
            f"{p.metadata.namespace}/{p.metadata.name}: {c.image}"
            for p in pods
            for c in self._all_containers(p)
            if c.image
            and (c.image.endswith(":latest") or ":" not in c.image)
            and not p.metadata.namespace.startswith("kube-")
        ]
        if latest_images:
            check.status = Status.FAIL
            check.finding = f"Unpinned image tags found: {', '.join(latest_images[:3])}"
            check.remediation = "Pin all images to specific digest or version tags"
        else:
            check.status = Status.PASS
            check.finding = "All images use pinned version tags"
        return check

    def _check_host_namespaces(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="RV.3.3",
            control_family="RV - Respond to Vulnerabilities",
            title="hostPID, hostNetwork, and hostIPC disabled",
            description="Pods must not share host PID, network, or IPC namespaces",
            severity="critical",
        )
        pods = (
            self.core_v1.list_namespaced_pod(namespace).items
            if namespace
            else self.core_v1.list_pod_for_all_namespaces().items
        )
        violations = [
            f"{p.metadata.namespace}/{p.metadata.name}"
            for p in pods
            if (p.spec.host_pid or p.spec.host_network or p.spec.host_ipc)
            and not p.metadata.namespace.startswith("kube-")
        ]
        if violations:
            check.status = Status.FAIL
            check.finding = f"Pods with host namespace access: {', '.join(violations)}"
            check.remediation = "Set spec.hostPID: false, spec.hostNetwork: false, and spec.hostIPC: false"
        else:
            check.status = Status.PASS
            check.finding = "No pods sharing host PID, network, or IPC namespaces"
        return check

    def _check_default_deny_policy(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="DS.1.1",
            control_family="DS - Distribute Securely",
            title="Default-deny NetworkPolicy present",
            description="A deny-all network policy should exist as the baseline",
            severity="high",
        )
        if not namespace:
            check.status = Status.SKIP
            check.finding = "Specify --namespace for this check"
            return check

        policies = self.networking_v1.list_namespaced_network_policy(namespace).items
        deny_all = [
            p
            for p in policies
            if (
                p.spec.pod_selector is not None
                and not p.spec.pod_selector.match_labels
                and not p.spec.pod_selector.match_expressions
            )
        ]
        if deny_all:
            check.status = Status.PASS
            check.finding = f"Default-deny policy found: {deny_all[0].metadata.name}"
        else:
            check.status = Status.FAIL
            check.finding = "No default-deny NetworkPolicy found in namespace"
            check.remediation = "Run: klustershield provision --namespace <ns>"
        return check

    def _check_secrets_not_in_env(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="DS.2.1",
            control_family="DS - Distribute Securely",
            title="Secrets not exposed as plain env vars",
            description="Secret values should be mounted as volumes, not environment variables",
            severity="high",
        )
        pods = (
            self.core_v1.list_namespaced_pod(namespace).items
            if namespace
            else self.core_v1.list_pod_for_all_namespaces().items
        )
        violations = []
        for p in pods:
            if p.metadata.namespace.startswith("kube-"):
                continue
            for c in self._all_containers(p):
                for env in c.env or []:
                    if env.value_from and env.value_from.secret_key_ref:
                        violations.append(f"{p.metadata.namespace}/{p.metadata.name}")
                        break

        if violations:
            check.status = Status.WARN
            check.finding = f"{len(violations)} pods exposing secrets as env vars"
            check.remediation = "Mount secrets as volumes using secretKeyRef in volumeMounts"
        else:
            check.status = Status.PASS
            check.finding = "No secrets detected as plain environment variables"
        return check

    def _check_rbac_configured(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="PV.1.1",
            control_family="PV - Verify with Automated Testing",
            title="RBAC roles configured in namespace",
            description="Namespace should have explicit RBAC roles defined",
            severity="high",
        )
        if not namespace:
            check.status = Status.SKIP
            check.finding = "Specify --namespace for this check"
            return check

        roles = self.rbac_v1.list_namespaced_role(namespace).items
        if roles:
            check.status = Status.PASS
            check.finding = f"Found {len(roles)} RBAC Role(s) defined"
        else:
            check.status = Status.WARN
            check.finding = "No explicit RBAC Roles found ‚Äî relying on ClusterRoles only"
            check.remediation = "Run: klustershield provision --namespace <ns>"
        return check

    def _check_service_account_tokens(self, namespace: str | None) -> ControlCheck:
        check = ControlCheck(
            control_id="PV.1.2",
            control_family="PV - Verify with Automated Testing",
            title="ServiceAccount token auto-mount disabled",
            description="Pods should set automountServiceAccountToken: false unless required",
            severity="medium",
        )
        pods = (
            self.core_v1.list_namespaced_pod(namespace).items
            if namespace
            else self.core_v1.list_pod_for_all_namespaces().items
        )
        auto_mounting = [
            f"{p.metadata.namespace}/{p.metadata.name}"
            for p in pods
            if p.spec.automount_service_account_token is not False and not p.metadata.namespace.startswith("kube-")
        ]
        if auto_mounting:
            check.status = Status.WARN
            check.finding = f"{len(auto_mounting)} pods auto-mounting ServiceAccount tokens"
            check.remediation = "Set spec.automountServiceAccountToken: false where not needed"
        else:
            check.status = Status.PASS
            check.finding = "ServiceAccount token auto-mount disabled on all pods"
        return check
